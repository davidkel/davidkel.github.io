### [TOC](./TOC.md)
### [Back - Data Storage and Registries](./datastorage.md)

# Query Language
Composer querys are converted to mango queries. These composer queries could either be `pre-converted` or converted on the fly. Pre-converted where the ones that were stored in the .qry file, whereas use of the buildQuery api call would convert the given query to a mango query. 

You will need to recreate your queries using the apache couchdb mango language then use the `getQueryResult` or `getQueryResultWithPagination` within your chaincode/smart contract. There is no inbuilt capability in the node-sdk to run mango queries directly in the same way you could just use the `buildQuery` and `query` apis in your client code. You would need to write a chaincode/smart contract function which invokes the getQueryResult call for the client.

In order to improve performance and allow for sorting the results, couchdb requires the use of `indexes` for information it stores. Composer would automatically generate indexes based on the queries defined in the `.qry` file for you. You will need to create these indexes yourself now. If you continue to use the `$class` field in your data (and it is highly recommended that you do) then you should include this field in your index. 
An example of a mango query and index file for trade `trade-network` business network for the query selectCommodotiesbyOwner

### Composer Query
```
query selectCommoditiesByOwner {
  description: "Select all commodities based on their owner"
  statement:
      SELECT org.example.trading.Commodity
          WHERE (owner == _$owner)
}
```

### Mango query
```
const lookupOwner = 'fred';
const query = `{"selector":{"\\\\$class":"${CommodityClass}","owner":"${lookupOwner}"}}`;
const iterator = await ctx.stub.getQueryResult(query);
```

And an example of getting all the results is

```
static async getAllResults(iterator) {
    let results = [];
    let res = {done: false};
    while (!res.done) {
        res = await iterator.next();
        if (res && res.value && res.value.value) {
            let val = res.value.value.toString('utf8');
            if (val.length > 0) {
                results.push(JSON.parse(val));
            }
        }
        if (res && res.done) {
            try {
                await iterator.close();
            }
            catch(err) {
                // log a warning
            }
            return results;
        }
    }
}
```

Note that if you get back a large result set this could have performance and resource implications.


### couchdb index file
```
{
    "index": {
        "fields": [
            "\\$class",
            "owner"
        ]
    },
    "name":"selectCommoditiesByOwner",
    "ddoc":"selectCommoditiesByOwner",
    "type":"json"
}
```
Note the use of the backslashes as this is important for these fields to work.

## More Query porting examples
Let’s firstly assume we are using the following example asset JSON structure, taken from a Composer model (the $class it is stored with is ‘org.acme.Commodity’ )
```
asset Commodity identified by id {
    o String id
    o String name
    o CommodityType commodityType
    o DateTime creationDate
    o InitialStatus status  
}
```
Let’s examine first, the Query Language equivalents, as a side-by-side comparison with Mango Queries (note these are shown ‘as-is’ – Indexing shows how you would optimize your query definition to use indices):

### Example 1

#### Composer Query
```
query getCommodity {
    description: "sample"
    statement:
        SELECT org.example.trading.Commodity
            WHERE (status == 'SCHEDULED')
                ORDER BY [creationDate ASC]
}
```
Note: The ‘ORDER BY’ – i.e. a SORT FIELD – requires an index in CouchDB – see next page on indexing.

#### Mango Query
That is, as generated by Composer: NOTE –  the string ‘\\’ below is required to escape special characters (e.g. ‘$’)  in Composer model field names, as shown below (if you are not accessing the business network data on an existing ledger, using Composer’s existing registry / namespace structure (i.e. post-porting), and using your own namespace structure, then these registry fields can be removed from the selectors below):

```
{"selector":
 {
  "\\$class":"org.example.trading.Commodity",
  "\\$registryType":"Asset",
  "\\$registryId":"org.example.trading.Commodity",
  "status":{"$eq":"SCHEDULED"}
 }
}
```

Query definition for porting purposes to Fabric 1.4 world (if re-using existing indexes, you should keep the ‘registry’ ID metadata in the Mango selector (as above) - if not (creating anew), remove it,  as you already have the $class ) –i.e. selector statement:

```
{"selector":
  {“\\$class”: “org.example.trading.Commodity”,
   "\\$registryType":"Asset",
   "\\$registryId":"org.example.trading.Commodity",
   "status": "SCHEDULED"
 }
}
```

### Example 2

#### Composer Query
```
Query {
identifier: 'SELECT org.example.trading.Commodity ' +
'WHERE ((commodityId == _$inputValue))'
}
```

#### Mango Query
Query definition for porting purposes in Mango Language (2 alternatives as an example) – the input value needs to be substituted, to evaluate to (e.g.) one of:

```
{"selector":
  {
  “\\$class”: “org.example.trading.Commodity”,
 "\\$registryType":"Asset",
 "\\$registryId":"org.example.trading.Commodity",
  "commodityId":"1234"
  }
 }
```

OR

```
{"selector":
   { 
   “\\$class”: “org.example.trading.Commodity”,
   "\\$registryType":"Asset",
  "\\$registryId":"org.example.trading.Commodity",
   "commodityId”: {"$eq":"1234"}
   }
 }
```

### Example 3

#### Composer Query
Composer query with concepts or arrays including CONTAINS clause

E.g. in the Composer Model for an asset:
o String[] loansBorrowed or
o Concept loansBorrowed (or Concept[] )

```
query q1 {
description: "Query"
statement:
SELECT org.acme.acme.SampleLoan
WHERE (loansBorrowed CONTAINS (loanamount > 5000))  }
```

JSON data (sample) to query:

```
{
“$class”: “org.acme.SampleLoan”,
"\\registryType”: “Asset”,
“\\$registryId":"org.acme.SampleLoan",
“id”, “12345”,
“name”, “JonDoe”,
"loansBorrowed": [
        {
          "loanamount": 5000,
          "loandate": "01/07/2001"
        },
        {
          "loanamount": 6000,
          "loandate": "01/01/2013"
        }
    ]
}
```

#### Mango Query
Using elemMatch for criteria match within an array  (in loansBorrowed array) and check that “loanamount > 5000”  and finally, return the fields ‘id’, ‘name’ and ‘loansBorrowed’ in the results:

```
{
  "selector": {
     “\\$class”: “org.acme.SampleLoan”, 
     “\\$registryType”: “Asset”,
     "\\$registryId":"org.acme.SampleLoan",
     “name”:”JonDoe”,
    "loansBorrowed": {
      "$elemMatch":  {
      "loanamount": {
          "$gt": 5000
        }
     }
   }
},
"fields": [
 “\\$class”,
  “name”,
 "loansBorrowed"
 ]
  use_index: “indexbyAmountdoc”
}
```

Alternative query definition – perform an ‘equals’ match  i.e. if “loanamount = 5000”

```
{
"selector": {
“\\$class”: “org.acme.SampleLoan”,
"\\registryType”: “Asset”,
“\\$registryId":"org.acme.SampleLoan",
 "loansBorrowed": {
         "$elemMatch": {
            "loanamount": {
               "$eq": 5000
            }
         }
      }
},
"fields": [
    "\\$class",
   “name”,
   "loansBorrowed"
 ],
 use_index: “indexbyAmountdoc”
}
```

Again – return the fields $class, ‘name’ and ‘loansBorrowed’ in the results.

and the matching index

```
{
  "index": {
    "partial_filter_selector": {},
    "fields": [
       "\\$class",
        "\\$registryType",
       "\\$registryId",
       “name”,
      "loansBorrowed.[].loanamount"
    ]
   },
   "name":"sampleLoansidx",
   "ddoc":"indexbyAmountdoc",
   "type":"json"
}
```

Here, you're only indexing specific fields and if the field contains an array, you're also indexing every element in the array (please note).


## Converting Composer Operators to Mango Operators

| Operator in Composer | Operator equivalent in Mango Query language |
| -------------------- | ------------------------------------------- |
| \< | \$lt |
| \<= | \$lte |
| \> | \$gt |
| \>= | \$gte |
| == | \$eq |
| != | \$ne |

## Indexing
As mentioned, Composer generated indexes for all fields in a query, using a consistent definition. When porting those generated indexes, there are a few factors to consider, when porting these to CouchDB native equivalents:
-	Removal of ‘Composer’ metadata in the auto-generated indexes (if you are planning on using a new ledger namespace / composite key structure for your state store.
-	Appraisal or otherwise of indexes, in terms of design*
-	Ensuring that matching indexes are created for the queries, in particular rich queries.

*Normally it's important to carefully design an index before creating a Mango query to use that index. Otherwise, the query planner may fall back to in-memory querying, which can be expensive. See example below using a query to define which index should be used, and the actual index as created in CouchDB.
One of the main things to note is that the ORDER of the fields matters when creating your index  - in particular, the order of ‘fields’ specified in the index should match, the order of the fields specified in the ‘selector’ (query build) definition.
Let’s compare (below) an original Composer Query, and the equivalent CouchDB query – then what the accompanying CouchDB index definition should look like (in the example below, we are using / maintaining the existing Composer registry-based data structures – hence the Composer specific registry fields shown which are required. If you are not using these `$` fields (\$class, \$registryType, \$registryId) they will need to be removed when porting.

### Composer Query with Sort field
```
query getCommodity {
    description: "sample"
    statement:
        SELECT org.acme.Commodity
            WHERE (owner  == 'resource:org.example.trading.Trader#TRADER1')
}
```

A mango query would look like 
```
{"selector":
         {"\\$class":"org.example.trading.Commodity",
          "\\$registryType":"Asset",
          "\\$registryId":"org.example.trading.Commodity",
          "owner":"resource:org.example.trading.Trader#TRADER1"
         },
          "use_index":  "tradeindexbyOwnerdoc"
}
```


The index required would be
```
{"index": {
  "partial_filter_selector": {},
   "fields": [
     "\\$class",
     "\\$registryType",
     "\\$registryId",
     "owner"
    ]
  },
   "name":"tradeselectByOwner",
   "ddoc":"tradeindexbyOwnerdoc",
   "type":"json"
}
```

**Note:** The Query and Index examples in this section of the document all include the \$class, \$registryType and \$registryId properties which are auto generated as “system” properties by Composer. It is recommended that only \$class needed to be included in new JSON data going forward.  Should readers implement this `$class only` approach, then the \$registryType and \$registryId should be removed from all the Queries and Indices in this section.

### Further Info on Indexes
A CouchDB index is generated in accordance with the CouchDB index specification – more information  and good examples can be found here http://docs.couchdb.org/en/stable/api/database/find.html#db-index  
For more insights into trade-offs on indexing strategies, for planning purposes – see this useful guide https://cloudant.com/blog/mango-json-vs-text-indexes/ 


### [Next - ACLs](./acls.md)